---
timestamp: 'Wed Oct 29 2025 20:29:48 GMT-0400 (Eastern Daylight Time)'
content_id: f93a4a69aca31a516a4ce821a2fbc0a6bd5269f0749cb11a41a51a4a87e55115
---

# file: src/concepts/PlayBack/PlayBackConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "../../utils/types.ts";
import * as Tonal from "npm:tonal";
import { INSTRUMENTS, MIN_SECONDS_PER_CHORD, MAX_SECONDS_PER_CHORD } from "@shared/constants.ts";

const PREFIX = "PlayBack" + ".";

type Progression = ID;
type Chord = string | null;

interface PlaybackSettings {
  _id: Progression;
  instrument: string;
  secondsPerChord: number;
};

export default class PlayBackConcept {
  private settings: Collection<PlaybackSettings>;

  constructor(private readonly db: Db) {
    this.settings = this.db.collection(PREFIX + "settings");
  }

  async initializeSettings(
    { progressionId }: { progressionId: Progression }
  ): Promise<{ settings: PlaybackSettings } | {error: string}> {
    const existingSettings = await this.settings.findOne({ _id: progressionId });
    if (existingSettings) {
      return {
        error: `Playback settings already exist for progression ID ${progressionId}.`,
      };
    }

    const defaultSettings: PlaybackSettings = {
      _id: progressionId,
      instrument: "Piano",
      secondsPerChord: 1,
    };

    await this.settings.insertOne(defaultSettings);
    return { settings: defaultSettings };
  }

  async setInstrument(
    { progressionId, instrument }: {
      progressionId: Progression;
      instrument: string;
    },
  ): Promise<Empty | { error: string }> {
    if (!INSTRUMENTS.includes(instrument)) {
      return { error: `Instrument must be one of ${INSTRUMENTS.join(", ")}.` };
    }

    const result = await this.settings.updateOne(
      { _id: progressionId },
      { $set: { instrument } },
    );

    if (result.matchedCount === 0) {
      return {
        error: `Playback settings for progression ID ${progressionId} not found.`,
      };
    }
    return {};
  }

  async setSecondsPerChord(
    { progressionId, secondsPerChord }: {
      progressionId: Progression;
      secondsPerChord: number;
    },
  ): Promise<Empty | { error: string }> {
    if (secondsPerChord < MIN_SECONDS_PER_CHORD || secondsPerChord > MAX_SECONDS_PER_CHORD) {
      return { error: `secondsPerChord must be between ${MIN_SECONDS_PER_CHORD} and ${MAX_SECONDS_PER_CHORD}.` };
    }

    const result = await this.settings.updateOne(
      { _id: progressionId },
      { $set: { secondsPerChord } },
    );

    if (result.matchedCount === 0) {
      return {
        error: `Playback settings for progression ID ${progressionId} not found.`,
      };
    }
    return {};
  }

  async getPlayBackSettings(
    { progressionId }: { progressionId: Progression }
  ): Promise<{ settings: PlaybackSettings } | { error: string }> {
    const settings = await this.settings.findOne({ _id: progressionId });
    if (!settings) {
      return {
        error: `Playback settings for progression ID ${progressionId} not found.`,
      };
    }
    return { settings: settings };
  }

  async getChordNotes(
    { chord }: { chord: Chord }
  ): Promise<{ notes: string[] } | { error: string }> {
    if (chord == null) {
      return { notes: [] };
    }
    
    const notes = Tonal.Chord.get(chord).notes;
    if (notes.length === 0) {
      return { error: `Invalid chord specified: '${chord}'.` };
    }

    const notesWithOctave = notes.map((note: string) => {
      const octaveIdx = note.length > 1 && (note[1] == '#' || note[1] == 'b') ? 2 : 1;
      return note.slice(0, octaveIdx) + '4' + note.slice(octaveIdx);
    });
    return { notes: notesWithOctave };
  }

  async getProgressionNotes(
    { progression }: { progression: Chord[] }
  ): Promise<{ notes: string[][] } | { error: string }> {
    const notes: string[][] = [];
    for (const chord of progression) {
      const response = await this.getChordNotes({ chord });
      if ("error" in response) {
        return { error: response.error };
      }
      notes.push(response.notes);
    }
    return { notes: notes };
  }
}
```
