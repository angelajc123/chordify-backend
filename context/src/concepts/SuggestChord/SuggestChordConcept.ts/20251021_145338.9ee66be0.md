---
timestamp: 'Tue Oct 21 2025 14:53:38 GMT-0400 (Eastern Daylight Time)'
content_id: 9ee66be082fcd35297c607849a417e8d15612ded4b3b2a0e1dc0d78e05538ae0
---

# file: src/concepts/SuggestChord/SuggestChordConcept.ts

```typescript
import { Collection, Db, ObjectId } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { GeminiLLM } from "@utils/gemini-llm.ts";

const NUM_SUGGESTIONS = 16;
const PREFIX = "SuggestChord" + ".";
type Progression = ID;

interface SuggestionPreferences {
  _id: Progression;
  preferredGenre: string;
  complexityLevel: string;
  key: string;
}

/**
 * @concept SuggestChord
 * @purpose offer users suggestions for suitable chords and progressions based on preferences
 */
export default class SuggestChordConcept {
  private preferences: Collection<SuggestionPreferences>;
  private llm: GeminiLLM;

  constructor(db: Db, llm: GeminiLLM) {
    this.preferences = db.collection(PREFIX + "preferences");
    this.llm = llm;
  }

  /**
   * @action initializePreferences
   * @requires progression does not exist in SuggestionPreferences
   * @effects creates a new SuggestionPreferences for progression with default values for preferredGenre, complexityLevel, and key.
   */
  async initializePreferences(
    { progressionId }: { progressionId: Progression },
  ): Promise<SuggestionPreferences | { error: string }> {
    const existing = await this.preferences.findOne({ _id: progressionId });
    if (existing) {
      return {
        error: `Preferences for progression ${progressionId} already exist.`,
      };
    }

    const newPreferences: SuggestionPreferences = {
      _id: progressionId,
      preferredGenre: "Pop",
      complexityLevel: "Basic",
      key: "Cmaj",
    };

    await this.preferences.insertOne(newPreferences);
    return newPreferences;
  }

  /**
   * @action setPreferredGenre
   * @requires progression exists in SuggestionPreferences
   * @effects updates the SuggestionPreferences for progression with the given genre.
   */
  async setPreferredGenre(
    { progressionId, preferredGenre }: {
      progressionId: Progression;
      preferredGenre: string;
    },
  ): Promise<Empty | { error: string }> {
    const result = await this.preferences.updateOne(
      { _id: progressionId },
      { $set: { preferredGenre } },
    );

    if (result.matchedCount === 0) {
      return { error: `Preferences for progression ${progressionId} not found.` };
    }
    return {};
  }

  /**
   * @action setComplexityLevel
   * @requires progression exists in SuggestionPreferences
   * @effects updates the SuggestionPreferences for progression with the given complexityLevel.
   */
  async setComplexityLevel(
    { progressionId, complexityLevel }: {
      progressionId: Progression;
      complexityLevel: string;
    },
  ): Promise<Empty | { error: string }> {
    const result = await this.preferences.updateOne(
      { _id: progressionId },
      { $set: { complexityLevel } },
    );

    if (result.matchedCount === 0) {
      return { error: `Preferences for progression ${progressionId} not found.` };
    }
    return {};
  }

  /**
   * @action setKey
   * @requires progression exists in SuggestionPreferences
   * @effects updates the SuggestionPreferences for progression with the given key.
   */
  async setKey(
    { progressionId, key }: { progressionId: Progression; key: string },
  ): Promise<Empty | { error: string }> {
    const result = await this.preferences.updateOne(
      { _id: progressionId },
      { $set: { key } },
    );

    if (result.matchedCount === 0) {
      return { error: `Preferences for progression ${progressionId} not found.` };
    }
    return {};
  }

  /**
   * @action getProgressionPreferences
   * @requires progression exists in SuggestionPreferences
   * @effects returns the SuggestionPreferences for progression.
   */
  async getProgressionPreferences(
    { progressionId }: { progressionId: Progression },
  ): Promise<
    { progressionPreferences: SuggestionPreferences } | {
      error: string;
    }
  > {
    const prefs = await this.preferences.findOne({ _id: progressionId });
    if (!prefs) {
      return { error: `Preferences for progression ${progressionId} not found.` };
    }
    return { progressionPreferences: prefs };
  }

  /**
   * @action suggestChord
   * @requires progression exists in SuggestionPreferences, 0 <= position < chords.length
   * @effects returns a list of suggested chords to put in position in chords, generated by an LLM
   *          given the context of the SuggestionPreferences for progression and the chords before and after it.
   */
  async suggestChord(
    { progressionId, chords, position }: {
      progressionId: Progression;
      chords: (string | null)[];
      position: number;
    },
  ): Promise<{ suggestedChords: string[] } | { error: string }> {
    if (position < 0 || position >= chords.length) {
      return { error: `Invalid position: ${position}. Must be within 0 and ${chords.length - 1}.` };
    }

    const prefs = await this.preferences.findOne({ _id: progressionId });
    if (!prefs) {
      return { error: `Preferences for progression ${progressionId} not found.` };
    }

    const currentProgressionString = chords.map((c) => c === null ? "EMPTY" : c).join(" - ");

    const prompt = `
      You are an expert harmony assistant specializing in Western tonal music theory.
      You generate harmonically coherent chord suggestions that fit naturally within a given chord progression, according to the musical key, genre, and complexity level.

      INPUT PARAMETERS
      - Key: ${prefs.key}
      - Genre: ${prefs.preferredGenre}
      - Complexity Level: ${prefs.complexityLevel}
      - Progression: ${currentProgressionString}
      - Position: ${position}
      - Number of Suggestions: ${NUM_SUGGESTIONS}

      Progressions are written using standard chord symbols (e.g., "C", "Am", "F", "G"), or "EMPTY" for missing chords.
      Positions are zero-indexed.

      YOUR TASK:
      Suggest ${NUM_SUGGESTIONS} musically appropriate chords for the given Position in the progression.

      Your suggestions should:
      - Respect the key and genre stylistic norms.
      - Reflect the complexity level (e.g., basic triads for beginner, extended or borrowed chords for advanced).
      - Fit smoothly with the surrounding chords (voice leading, harmonic function).
      - Include both diatonic and non-diatonic options when musically justified (e.g., secondary dominants, borrowed chords, tritone substitutions).
      - Order chords by musical likelihood or functional smoothness.

      OUTPUT FORMAT:
      Return only a comma-separated list of chord names.
      Do not include explanations, commentary, or markdown.
    `;

    try {
      const llmResponse = await this.llm.executeLLM(prompt);
      const suggestedChords = llmResponse
        .split(",")
        .map((s) => s.trim())
        .filter(Boolean); // Filter out empty strings

      if (suggestedChords.length === 0) {
        return { error: "LLM did not return valid chord suggestions." };
      }

      return { suggestedChords };
    } catch (e) {
      const error = e as Error;
      console.error(`Error during LLM chord suggestion: ${error.message}`);
      return { error: `Failed to get chord suggestions: ${error.message}` };
    }
  }

  /**
   * @action suggestProgression
   * @requires progression exists in SuggestionPreferences, length > 0
   * @effects returns a chord progression of length length, generated by an LLM
   *          given the context of the SuggestionPreferences for progression.
   */
  async suggestProgression(
    { progressionId, length }: { progressionId: Progression; length: number },
  ): Promise<{ chordSequence: string[] } | { error: string }> {
    if (length <= 0) {
      return { error: `Invalid length: ${length}. Must be greater than 0.` };
    }

    const prefs = await this.preferences.findOne({ _id: progressionId });
    if (!prefs) {
      return { error: `Preferences for progression ${progressionId} not found.` };
    }

    const prompt = `
      You are an expert harmony assistant specializing in Western tonal music theory.
      You generate complete, harmonically coherent chord progressions that fit naturally within a given key, genre, and complexity level.

      INPUT PARAMETERS
      - Key: ${prefs.key}
      - Genre: ${prefs.preferredGenre}
      - Complexity Level: ${prefs.complexityLevel}
      - Progression Length: ${length}

      Each progression should:
      - Be ${length} chords long.
      - Use standard chord symbols (e.g., "C", "Am", "F", "G").
      - Be harmonically consistent and stylistically appropriate for the given genre and complexity level.

      YOUR TASK:
      Generate a distinct, musically coherent chord progression that fit within the given key, genre, and complexity level.

      Your progressions should:
      - Respect the key and genre’s stylistic conventions.
      - Reflect the specified complexity level (e.g., simple triads for beginner; extended, altered, or borrowed chords for advanced).
      - Demonstrate smooth voice leading and clear harmonic function.
      - Include both diatonic and tasteful non-diatonic chords when appropriate (e.g., secondary dominants, modal interchange, tritone substitutions).
      - Follow common functional patterns (e.g., tonic–subdominant–dominant–tonic, ii–V–I in jazz, I–V–vi–IV in pop) unless the genre suggests otherwise.

      OUTPUT FORMAT:
      Return a comma-separated list of chord names.
      Do not include explanations, commentary, or markdown.
    `;

    try {
      const llmResponse = await this.llm.executeLLM(prompt);
      const chordSequence = llmResponse
        .split(",")
        .map((s) => s.trim())
        .filter(Boolean); // Filter out empty strings

      if (chordSequence.length === 0) {
        return { error: "LLM did not return a valid chord progression." };
      }
      if (chordSequence.length !== length) {
          console.warn(`LLM returned ${chordSequence.length} chords but ${length} were requested. Adjusting.`);
          // If LLM doesn't match length, try to truncate/pad. For simplicity, just return what was given.
      }

      return { chordSequence };
    } catch (e) {
      const error = e as Error;
      console.error(`Error during LLM progression suggestion: ${error.message}`);
      return { error: `Failed to get progression suggestion: ${error.message}` };
    }
  }
}
```
